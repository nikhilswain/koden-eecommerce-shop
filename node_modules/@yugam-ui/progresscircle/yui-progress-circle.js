let yuiProgressCircle = document.createElement('template');

yuiProgressCircle.innerHTML = `

  <style>

  :host {
    --stroke: #409eff !important;
    --stroke-dashoffset: 440 ;
  }

  /* svg for progress bar cirlce */
  svg.progresscircle{
      position: relative;
      width: 150px;
      height: 150px;
      z-index: 1000;
      transform: rotate(-90deg);
    }

    svg.progresscircle circle {
      width: 100%;
      height: 100%;
      fill: none;
      stroke: #b8b8b8;
      stroke-width: 10;
      stroke-linecap: round;
      transform: translate(5px, 5px);
    }

    svg.progresscircle circle:nth-child(2) {
      stroke-dasharray: 440;
      stroke-dashoffset: 440;
    }

    svg.progresscircle circle:nth-child(2) {
      stroke-dashoffset: calc(440 - (440 * 0) / 100); /* default value 0 of progressbar circle */
      stroke: #409eff;
    }

.gradient1 {
  stop-color: var(--gradient1) !important;
}

.gradient2 {
  stop-color: var(--gradient2) !important;
}
 
    circle:nth-child(2){
      transition: all 1s linear;
      animation: strokeDefaultCircle 2s linear  ;
    }

 /*  svg for progress cirlce loading state */
  @keyframes strokeDefaultCircle {
      0% {
        stroke-dashoffset: 440;
      }
      100% {
        stroke-dashoffset: var(--stroke-dashoffset);
     /*   somehow this requires actual value and not by calc function to animate need to find a way to update this with js to perform animation*/
      }
    }
  
.progresscircle-container {
  display: inline-flex;
  position: relative;
  justify-content: center;
  align-items: center;
} 

.progresscircle-container span {
  position: absolute;
}

.progresscircle-container span.tick {
 display: none;
}

.progresscircle-container span.cross{
  display: none;
}

 /* styles for progress loading bar */
  .circular-loader {
        -webkit-animation: rotate 2s linear infinite;
        animation: rotate 2s linear infinite;
        height: 150px;
        -webkit-transform-origin: center center;
        transform-origin: center center;
        width: 150px;
       display: none;
      }

      .loader-path {
        stroke-dasharray: 150, 200;
        stroke-dashoffset: -10;
        -webkit-animation: dash 1.5s ease-in-out infinite, color 6s ease-in-out infinite;
        animation: dash 1.5s ease-in-out infinite, color 6s ease-in-out infinite;
        stroke-linecap: round;
      }

      @-webkit-keyframes rotate {
        100% {
          -webkit-transform: rotate(360deg);
          transform: rotate(360deg);
        }
      }

      @keyframes rotate {
        100% {
          -webkit-transform: rotate(360deg);
          transform: rotate(360deg);
        }
      }
      @-webkit-keyframes dash {
        0% {
          stroke-dasharray: 1, 200;
          stroke-dashoffset: 0;
        }
        50% {
          stroke-dasharray: 89, 200;
          stroke-dashoffset: -35;
        }
        100% {
          stroke-dasharray: 89, 200;
          stroke-dashoffset: -124;
        }
      }
      @keyframes dash {
        0% {
          stroke-dasharray: 1, 200;
          stroke-dashoffset: 0;
        }
        50% {
          stroke-dasharray: 89, 200;
          stroke-dashoffset: -35;
        }
        100% {
          stroke-dasharray: 89, 200;
          stroke-dashoffset: -124;
        }
      }
      @-webkit-keyframes color {
        0% {
          stroke: var(--stroke);
        }
        40% {
          stroke: var(--stroke);
        }
        66% {
          stroke: var(--stroke);
        }
        80%,
        90% {
          stroke: var(--stroke);
        }
      }
      @keyframes color {
        0% {
          stroke: var(--stroke);
        }
        40% {
          stroke: var(--stroke);
        }
        66% {
          stroke: var(--stroke);
        }
        80%,
        90% {
          stroke: var(--stroke);
        }
      }


  

  </style>
<!-- svg for loading progress bar -->
<div>
  <svg class="circular-loader" viewBox="25 25 50 50">
      <circle class="loader-path" cx="50" cy="50" r="20" fill="none" stroke="var(--stroke)" stroke-width="3" />
  </svg>
</div>

  <!-- svg for progress bar circle -->
  <div class="progresscircle-container"> 
  <svg class="progresscircle">
      <circle cx="70" cy="70" r="70"></circle>
      <circle cx="70" cy="70" r="70" class="progress"  ></circle>
      <g transform="translate(145, 0)">
      <text x="50%" y="50%" fill="#393E46" font-size="1.5em" font-weight="600" text-anchor="middle" transform="rotate(90)" dy=".3em" class="progress-text"></text>
      </g>
  </svg>
  <span class="tick">
  <svg viewBox="64 64 896 896" focusable="false" data-icon="check" width="3em" height="3em" fill="#67c23a" aria-hidden="true"><path d="M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z"></path></svg>
  </span>   
  <span class="cross">
  <svg viewBox="64 64 896 896" focusable="false" data-icon="close" width="3rem" height="3rem" fill="#dc3545" aria-hidden="true"><path d="M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z"></path></svg>
  </span>
  </div>

`;

class progressCircle extends HTMLElement {
  static get observedAttributes() {
    return [
      'value',
      'status',
      'type',
      'style',
      'color',
      'loading',
      'text',
      'confirm',
    ];
  }

  //  value based attributes
  get value() {
    return this.getAttribute('value');
  }

  set value(val) {
    if (val) {
      this.setAttribute('value', val);
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'value') i.onChange();
      });
    } else {
      this.removeAttribute('value');
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'value') i.onRevert();
      });
    }
  }

  get type() {
    return this.getAttribute('type');
  }

  set type(val) {
    if (val) {
      this.setAttribute('type', val);
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'type') i.onChange();
      });
    } else {
      this.removeAttribute('type');
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'type') i.onRevert();
      });
    }
  }

  get text() {
    return this.getAttribute('text');
  }

  set text(val) {
    if (val) {
      this.setAttribute('text', val);
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'text') i.onChange();
      });
    } else {
      this.removeAttribute('text');
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'text') i.onRevert();
      });
    }
  }

  get color() {
    return this.getAttribute('color');
  }

  set color(val) {
    if (val) {
      this.setAttribute('color', val);
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'color') i.onChange();
      });
    } else {
      this.removeAttribute('color');
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'color') i.onRevert();
      });
    }
  }

  get status() {
    if (this.hasAttribute('status'))
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'status') i.onChange();
      });
    else
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'status') i.onRevert();
      });
  }

  get loading() {
    if (this.hasAttribute('loading'))
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'loading') i.onChange();
      });
    else
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'loading') i.onRevert();
      });
  }

  get confirm() {
    return this.getAttribute('confirm');
  }

  set confirm(val) {
    if (val) {
      this.setAttribute('confirm', val);
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'confirm') i.onChange();
      });
    } else {
      this.removeAttribute('confirm');
      this.progressbarAtrribute.forEach((i) => {
        if (i.name === 'confirm') i.onRevert();
      });
    }
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.appendChild(yuiProgressCircle.content.cloneNode(true));

    // progress bar circle element
    this.progressCircleContainer = this.shadowRoot.querySelector(
      '.progresscircle-container'
    );
    this.progressCircle = this.shadowRoot.querySelector('.progress');
    this.progressCircleParent =
      this.shadowRoot.querySelector('.progresscircle');
    this.progressCircleText = this.shadowRoot.querySelector('.progress-text');

    //progress loading cirle element
    this.progressLoading = this.shadowRoot.querySelector('.circular-loader');
    //defining types of attributes
    this.booleanAttirbutes = ['status', 'loading'];
    this.valueAttributes = ['value', 'type', 'color', 'text', 'confirm'];

    //function to trigger on both changes in confirm and value attributes.
    const confirmFunction = () => {
      if (this.hasAttribute('status')) this.progressCircleText.innerHTML = '';

      if (this.confirm === 'success') {
        this.progressCircleContainer.children[1].style.display = 'block';
        this.progressCircle.style.stroke = '#67c23a';
      } else if (this.confirm === 'fail') {
        this.progressCircle.style.stroke = '#dc3545';
        this.progressCircleContainer.children[2].style.display = 'block';
      } else if (this.confirm === 'both') {
        if (this.value == 0) {
          this.progressCircleContainer.children[1].style.display = 'none';
          this.progressCircleContainer.children[2].style.display = 'block';
        } else if (this.value == 100) {
          this.progressCircleContainer.children[1].style.display = 'block';
          this.progressCircleContainer.children[2].style.display = 'none';
          this.progressCircle.style.stroke = '#67c23a';
        } else {
          this.progressCircleContainer.children[1].style.display = 'none';
          this.progressCircleContainer.children[2].style.display = 'none';
          this.progressCircle.style.stroke = '#40a9ff';
        }
      }
    };

    this.progressbarAtrribute = [
      {
        name: 'value',
        onChange: () => {
          let value = 440 - (440 * this.value) / 100;
          this.progressCircle.style.setProperty('--stroke-dashoffset', value);
          this.progressCircle.style.strokeDashoffset = value;
          if (this.hasAttribute('status'))
            this.progressCircleText.innerHTML = this.value + '%';
          if (this.hasAttribute('confirm')) confirmFunction();
        },
        onRevert: () => {
          if (this.hasAttribute('status'))
            this.progressCircleText.innerHTML = '0%';
          this.progressCircle.style.strokeDashoffset = 440 - (440 * 0) / 100;
        },
      },
      {
        name: 'status',
        onChange: () => {
          //checking if the value is null ( can be null if the value attribute is removed, value of this.value becomes null)
          if (this.hasAttribute('confirm'))
            this.progressCircleText.innerHTML = '';
          else if (this.value === null)
            this.progressCircleText.innerHTML = '0%';
          else this.progressCircleText.innerHTML = this.value + '%';
        },
        onRevert: () => {
          this.progressCircleText.innerHTML = '';
        },
      },
      {
        name: 'type',
        onChange: () => {
          if (this.hasAttribute('loading')) {
            if (this.type === 'success')
              this.progressLoading.children[0].style.setProperty(
                '--stroke',
                '#67c23a'
              );
            else if (this.type === 'info')
              this.progressLoading.children[0].style.setProperty(
                '--stroke',
                '#17a2b8'
              );
            else if (this.type === 'warning')
              this.progressLoading.children[0].style.setProperty(
                '--stroke',
                '#ffc107'
              );
            else if (this.type === 'danger')
              this.progressLoading.children[0].style.setProperty(
                '--stroke',
                '#dc3545'
              );
            else
              this.progressLoading.children[0].style.setProperty(
                '--stroke',
                '#409eff'
              );
          } else {
            if (this.type === 'success')
              this.progressCircle.style.stroke = '#67c23a';
            else if (this.type === 'info')
              this.progressCircle.style.stroke = '#17a2b8';
            else if (this.type === 'warning')
              this.progressCircle.style.stroke = '#ffc107';
            else if (this.type === 'danger')
              this.progressCircle.style.stroke = '#dc3545';
            else this.progressCircle.style.stroke = '#409eff';
          }
        },
        onRevert: () => {
          this.progressCircle.style.stroke = '#409eff';
          this.progressLoading.children[0].style.setProperty(
            '--stroke',
            '#409eff'
          );
        },
      },
      {
        name: 'color',
        onChange: () => {
          this.progressCircle.style.stroke = this.color;
          this.progressLoading.children[0].style.setProperty(
            '--stroke',
            this.color
          );
        },
        onRevert: () => {
          this.progressCircle.style.stroke = '#409eff';
          this.progressLoading.children[0].style.setProperty(
            '--stroke',
            '#409eff'
          );
        },
      },
      {
        name: 'loading',
        onChange: () => {
          this.progressCircleParent.style.display = 'none';
          this.progressLoading.style.display = 'inline-block';
        },
        onRevert: () => {
          this.progressCircleParent.style.display = 'inline-block';
          this.progressLoading.style.display = 'none';
        },
      },
      {
        name: 'confirm',
        onChange: () => {
          confirmFunction();
        },
        onRevert: () => {
          if (this.hasAttribute('status'))
            this.progressCircleText.innerHTML = this.value + '%';
          this.progressCircleContainer.children[1].style.display = 'none';
          this.progressCircleContainer.children[2].style.display = 'none';
          this.progressCircle.style.stroke = '#409eff';
        },
      },
      {
        name: 'text',
        onChange: () => {
          this.progressCircleText.innerHTML = this.text;
        },
        onRevert: () => {
          this.progressCircleText.innerHTML = this.value + '%';
        },
      },
    ];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    // if inline style is implemented directly on the yui-progress-pie element
    if (this.hasAttribute('style')) {
      if (this.hasAttribute('loading'))
        this.progressLoading.parentElement.style = this.getAttribute('style');
      //for inline styles
      else this.progressCircleParent.style = this.getAttribute('style'); //for inline styles
    }
    if (this.booleanAttirbutes.includes(name)) {
      this[name];
    }

    this.valueAttributes.forEach((attribute) => {
      if (attribute === name) {
        if (oldValue !== newValue) {
          switch (name) {
            case 'value':
              //  if value is changed to something acceptable
              if (newValue > 100) this.value = 100;
              else if (newValue < 0 || newValue === '' || newValue === null)
                this.value = 0;
              else this.value = newValue; //  updating this.value for onChange()
              break;

            case 'type':
              if (newValue === '') this.type = '';
              else this.type = newValue;
              break;

            case 'color':
              if (newValue === '') this.color = '';
              else this.color = newValue;
              break;
            case 'text':
              if (newValue === '' || newValue === null)
                this.progressCircle.innerHTML = this.value + '%';
              else if (this.hasAttribute('status'))
                this.progressCircle.innerHTML = this.value + '%';
              else this.text = newValue;
              break;
            case 'confirm':
              if (newValue === '') this.confirm = '';
              else this.confirm = newValue;
              break;
          }
        }
      }
    });
  }
}

customElements.define('yui-progress-circle', progressCircle);
